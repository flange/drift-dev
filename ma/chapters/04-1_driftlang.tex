\subsection{The Drift Language}
\label{driftlang}

Developing a programming language can be an overwhelmingly
ambitious task. Most often it's only that when one sets out
to do so, that one realizes how many features even
basic languages offer: arithmetic, different types of loops,
conditionals, logical operators, built-in data types and a
type system that allows for arbitrary user-defined types.
Depending on the overall paradigm the list might continue
with things like classes, objects, inheritance, polymorphism
and generic types or things like type classes, higher-order
functions, partial application or monads and do-notation.

Although it would have been nice to have at least scratched on
some of these aspects, it became clear right at the beginning
that most of these features would be left untouched given the
scope and resources of the work presented here.

But that is not necessarily a bad thing. Constraints often times
have the benefit that they force resources to be spent on what
really matters and so in that same spirit the goal for the
Drift coordination language was to carve out what is
\textit{essential} to programming. It could almost be said that
the goal was to find the smallest possible language that
would not allow for any construct to be taken out and still be
offering the same possibilities.
\newline

So what is the essence of programming?

Well that depends on what the user is supposed to be able to express
in that language. If it's computation through calculation, built-in
arithmetic operators like $+$ or $*$ might seem a good idea. If
the user should be able to express things that model the real world,
like in many simulation contexts for example, having constructs
that represent real world objects and allow for equipping them with
properties like color or weight could be another sensible approach,
built on basic arithmetic. This would naturally lead to built-in
data types for which these basic arithmetic operators are
defined and would build up to a type system which could deal with
arbitrary user-defined types and the operations defined on them.

But defining these structures, functions or classes and modelling their
properties and functionalities is only one part of constructing
a program because these structures in and by themselves have nothing
on which they could execute their behavior on and are not connected
in any way in order to produce a final output as the result of
multiple functionalities chained together.

A program does not only exist as the mere sum of its parts but
also of a description of how these parts interact and compose and
where data comes from and where it goes which is what is mostly
described inside the \textit{main-method} which virtually
all programming languages independent of their paradigm have in
common because it serves as the universal starting point of a program.

Most languages use the same syntax and semantics
for both purposes: for describing the individual components and for
describing their often times more abstract orchestration.
This is demonstrated by the examples shown in Fig.\ref{c-and-java}.

\begin{figure}[h!]
    \vspace{5mm}
    \begin{subfigure}[b]{0.41\textwidth}

    \begin{lstlisting}
#include <stdio.h>

struct point {
  int x;
  int y;
};

int point_sum(struct point p) {
  return (p.x + p.y);
}

int main() {

  struct point p;
  p.x = 3;
  p.y = 5;

  printf("%d\n", point_sum(p));

  return 0;
}
    \end{lstlisting}

      \caption{Component definition and orchestration in C.}
      \label{fig:c-example}
    \end{subfigure}
    \hfill
    \vspace{10pt}
    \begin{subfigure}[b]{0.54\textwidth}

    \begin{lstlisting}
public class Point {
  private int x;
  private int y;

  public Point(int x, int y) {
    this.x = x;
    this.y = y;
  }

  public int getSum() {
    return (this.x + this.y);
  }

  public static void main(String[] args){

    Point p = new Point(3, 5);
    System.out.println(p.getSum());

    return;
  }
}
    \end{lstlisting}

      \caption{Component definition and orchestration in Java.}
      \label{fig:java-example}
    \end{subfigure}

  \caption{Examples of component definition and orchestration done in
           languages that use the same language for both tasks.}
  \label{c-and-java}

\end{figure}

The left hand side figure, Fig.\ref{c-and-java}a, shows an example
using the C programming language. In it, a new compound user-defined
data type \textit{point} is declared and defined, consisting of two
integers representing the x and y coordinates of a point.
Then a function is declared and defined which takes such a point
as an input and returns the sum of its coordinates.

These are the blue prints of the components of this tiny system.
Inside the main-methode an instance of a point is created and
its coordinates are set to the values 3 and 5, which are part of
the source code itself. Then a function call is issued using a copy of
this point instance which creates a single instance of the mentionend
function whose return value is then immediately printed to the screen.

So inside the main method the actual \textit{business logic} of
the program is described by composing and chaining instances of the
described components and inserting data into the system and letting
it flow through the components in order to produce the desired output.
\newline

The same thing happens in the example on the right hand side, in
Fig.\ref{c-and-java}b, this time using the object oriented
programming language Java. In this example a class \textit{Point} is
defined, also using two integers to represent its coordinates.
The class defines two methods: a constructor method for ease of
instantiation and a \textit{getSum(int, int)} method to again
calculate the sum of the coordinates.

As with the C example on the left, this plain class definition
by itself would not make for much of a program. The business logic
is again defined in the main-method, where an instance of the Point
class, a Point object, is instantiated (again with data contained
inside the source code file itself) and the result of a call to
its instance method \textit{getSum} is printed.
\newline

However, it is possible to disentangle the component description
from the higher level component composition. One example of this
has already been introduced, namely the UNIX stack as shown in
Fig.\ref{unixstack}. In this stack, each component is a UNIX
process, dealing only with the task of processing the data its
been given and producing its output respectively. The higher-level
business logic of the system is then defined using the shell
which can be used to instantiate components (processes),
just like objects are instantiated in Java, and describe the data
flow between them. The difference is, that the shell language, the
\textit{coordination language} is completely
different compared to the \textit{computation language} used to
describe the computation done by each individual process.

So which of the two, computation or coordination, is actually
more relevant in the context of programming a distributed system?
Well, how would one distribute a computation like $1 + 2$?
Computation in and by itself has something local about it because
the operator needs to have perceived or received its operands in
order to carry out its computation. The \textit{distributedness}
actually emerges because although each individual operation is
carried out on a local machine, the actuall composition of multiple
operations and data flow through them spans multiple locations, i.e.
multiple machines.

So as I have already tried to argue in chapter \ref{LanguageEvolution},
for the context of distributed systems, it's not so much computation
that defines the programming of distributed systems (because
of computation having this inherently local aspect to it, we
can for the most part reuse the already existing computation languages)
but rather \textit{coordination} and \textit{communication} between
the components and operations residing on different machines.
\newline

So the question of what is the essence of programming
changes in the context of distributed systems and therefor for the
context of this work to: what is the essence of composition?
\newline

To me, as far as I can work out, the essence of composition
is simply \textit{data} and \textit{functionality}. Whether
functionality is provided by plain functions modelled after
the example of mathematical functions, or with objects that
encapsulate functionality via methods, or with actors or
processes or microservices is not really important.

I believe the user needs these two things: she needs to be
able to identify and talk about her data and she needs to be
able to identify and invoke her services with that data.
This also includes identifying the data that might be the
result of such a service invocation.

So what's the most natural way for \textit{people} to identify things?
By giving them \textit{names}. Names that carry \textit{meaning}
and therefor provide semantics (for humans).
\newline

\textit{Meaning} is an interesting word and one can easily find examples
where it is ascribed to mechanisms that do not really provide it.
For example one of the fundamental books on programming language
semantics and type systems, \textit{Types and Programming Languages}
by Pierce \cite{pierce} contains the following quote by Mark Manasse
on page 208:

\begin{quote}
The fundamental problem addressed by a type theory is to ensure
that programs have meaning. The fundamental problem caused by a
type theory is that meaningful programs may not have meanings ascribed
to them. The quest for richer type systems results from this tension.
\end{quote}

In this quote, type systems are identified as the source of
meaning for programs and there is some truth to that. But I
would like to argue that it is not the type system itself that
provides the meaning, but rather the \textit{names} of the types
that do so.
\newpage

\begin{wrapfigure}{l}{0.54\textwidth}
  \begin{lstlisting}
void runServer(ServerSocket serverSock) {
  serverSock.listenOnPort(9000);
}
  \end{lstlisting}


  \begin{lstlisting}
void runServer(Uhjgj abcdeg) {
  abcdeg.inufdhg(9000);
}
  \end{lstlisting}

  \begin{lstlisting}
void runServer(143 abcdeg) {
  abcdeg.inufdhg(9000);
}
  \end{lstlisting}
  \caption{Example showing the importance of \textit{names} for
           human understanding and reasoning about code.}
  \label{type-names}
\end{wrapfigure}

Consider for example the three versions of the same function in
Fig.\ref{type-names}. The first version represents the kind of
code that is used in software development today, using meaningful
names not only for the data types but for the variable names as well.
This makes it easy for humans to understand why a server socket
has a method that triggers listening on a port and why this method
receives a number as input. Most of the meaning is conveyed through
the names, if chosen appropriately.

In the second version the names are obfuscated but still used as
expected by the compiler. This will happily compile, but most of its
meaning is gone. The third version reduces the type identifier to
a number. Most language grammars do not allow for type names to
be numbers, so this won't compile but the type checking engine itself
would probably still accept it. Because to the type checker, the type
is just an ID and as along as it can check whether or not the type
with the ID 143 provides a method with the used identifier and
signature, it would not raise any flags.
\newline

The \textit{meaning} is not conveyed by types. It's conveyed
by the \textit{names} of the types and of course the names of
variables, methods, classes, objects, and so on.
\newline

\begin{wrapfigure}{l}{0.4\textwidth}
  \begin{lstlisting}
int add_one(int n) {
  return (n - 1);
}
  \end{lstlisting}
  \caption{Example showing a bug that cannot be detected by
           the compiler or type checker.}
  \label{add-one}
\end{wrapfigure}

Consider another example, shown in Fig.\ref{add-one}. This example
shows a simple function whose name suggests that it returns its
argument incremented by one. Unfortunately its code does the exact
opposite and returns the decremented input. This will also
happily compile because \textit{add\_one} is a valid function identifier
and \textit{n - 1} is a valid operation on integers. But we as people
will immediate spot the mismatch between the meaning of its name and
its provided functionality.

So when one tries to reduce coordination down to its core parts,
namely data and services, the essential abstract thoughts that can
be expressed by the programmer are something like ``do this on that'',
or ``do this on that and put the result there'', or ``do this
on that and then that and put the final result over there''.
Interestingly even on such an abstract and rather comical scale,
these abstract statements can be categorized into two groups.
They are either describing a functionality chain, where each
component depends on the output of its predecessor and they
all form a sort of pipeline through which the data flows
sequentially or the services are completely independent of
one another.

So naturally the formulation of data and services forms a
dependency tree or, depending on the allowed complexity,
a directed acyclic graph (DAG). Which can be used effectively
for visualizations as will be shown in later chapters.
\newline

And so, in that same spirit, the basic concepts of the \textit{Drift}
language are \textit{names} to represent data and \textit{services}
to represent functionality.

\begin{figure}[h]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}

  \begin{lstlisting}
.> Cat mydata
Lorem ipsum dolor sit amet,
consectetur adipiscing elit.
.>
  \end{lstlisting}

        \caption{Simple service invocation.}
        \label{cat1}
    \end{subfigure}
    \hspace{20pt} %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}[b]{0.4\textwidth}

  \begin{lstlisting}
.> myresult = Cat mydata
.>
  \end{lstlisting}

        \caption{Service invocation with result bound to a name.}
        \label{cat2}
    \end{subfigure}
    \caption{Basic service invocation mechanism in Drift.}\label{drift-examples1}
\end{figure}

Fig.\ref{drift-examples1} shows the basic concepts offered by
the \textit{Drift language} as implemented by the \textit{Drift shell}.
In the Drift language, service names are required to
start with an upper case letter, whereas names representing
data are to be started with a lower case letter. The $.>$ symbolizes
the shell prompt. The first example of Fig.\ref{cat1}
shows the most basic use case: a simple service invocation.
Following the tradition of the UNIX shell, Drift uses the same
order of command and arguments, namely
$Service\ name_{1}\ ...\ name_{n}$.
Depending on the called service it would also be possible to
invoke services without any parameter names.

Since Drift is eager-evaluated the service shown in
Fig.\ref{cat1} is immediately started. In this case it's
a service called \textit{Cat} in reference to the widely-known
UNIX tool, which prints the content of given files to the screen.
So the \textit{Cat} service also returns the data of its arguments and
since there are only names in Drift, the \textit{Cat} services takes names
as input and returns the data associated with them.

Since the data returned by the invocation of the \textit{Cat} service is
not bound to any name, it just gets printed to the shell. When all
the data that is available behind the name(s) given to \textit{Cat} has been
printed, a new shell prompt is shown and further commands can be entered
by the user.

Fig.\ref{cat2} shows the same service invocation but this time the
result of the service call is bound to a name, using the assignment
syntax as known from other imperative languages. Again the
\textit{Cat} service is invoked immediately but since its result
is bound to a name, nothing is printed to the screen except a new
prompt so that new commands can be entered.

\begin{figure}[h]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}

  \begin{lstlisting}
.> myresult = Cat mydata
.> $myresult
Lorem ipsum dolor sit amet,
consectetur adipiscing elit.
.>
  \end{lstlisting}

        \caption{Using the \$-operator to query the data behind a name.}
        \label{cat3}
    \end{subfigure}
    \hspace{20pt} %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}[b]{0.4\textwidth}

  \begin{lstlisting}
.> Cat mydata
Lorem ipsum dolor sit amet,
[cancel]
.>
  \end{lstlisting}

        \caption{Canceling an ongoing data query.\\}
        \label{cat4}
    \end{subfigure}
    \caption{Basic query and query cancelation mechanism in Drift.}\label{drift-examples2}
\end{figure}

In order to query the data that is represented by a name, Drift offers
the \$-operator, a designated query operator, as shown in \ref{cat3}.
This query operator will receive \textit{all} the data available
behind a name and print it straight to the screen.

However, since services are invoked immediately and therefor executed
immediately, it is possible that the service has not yet produced
a single data item or has not yet finished processing and has
therefor not finished producing all of its output. This means that
it is absolutely possible that either no data or only some data is
shown, depending on what's available when the user issues the query.
\newline
Drift is not an \textit{all or nothing} batch system where the user
either sees no output, or all the output atomically. It's a streaming
system in which data is observable whenever it is available. This is
based on the observation that batch processing, even distributed
batch processing, is only \textit{a special case} of stream processing
and not the other way around, as was also proclaimed in
\cite[chapter 1]{flink}. This fits perfectly with the overall
approach of immediate feedback because not only the commands of
the shell are eagerly evaluated and because of that the services
immediately spawned, but also the data produced by the individual
components flowing through the system can be immediately observed
by the user.
\newline
Of course it would defeat the purpose and reactiveness of the system
if the user would have to wait for all the data to be finished, once
querying a name. Therefor query cancelation has been implemented as
shown in Fig.\ref{cat4}. When data is printed to the screen, either
because the result of the producing service invocation was not bound
to a name, or because a name was queried using the \$-operator, the
display of data can be canceled simply by pressing $q$ and new prompt
will be shown so that new actions can be taken.

Therefor printing data to the screen has not the role of presenting
real results, like in many batch processing systems. It rather becomes
a tool for the user to sneak a peek at what the system is currently
doing in order to assess whether or not the system is working
towards the desired result.
\newline

So where do all the available services and names come from?
In the same way that the UNIX shell does not provide much
built-in functionality except for only a very few built-in
commands, the Drift shell also does not provide any services.
Services need to be inserted into a \textit{service registry}.

This is a designated service invisible to the user that the
Drift shell assumes to be available at all times. When a command
is entered, the shell will consult the service registry about
whether the service exists and whether its usage corresponds to
its specification stored in the service registry.

However the shell does not \textit{download} the required service
in any way. It only fact-checks the service before issuing the
entered command as a task to the back-end system, as will be
described in chapter \ref{driftimplementation}.
If a service is unknown to the service registry, a
\textit{service unknown} error will be printed to the screen
and a new prompt is shown.
\newline

The availability of names is different. One of the design goals
of the Drift shell is to present the user with its own cloud so
to speak. Therefor any Drift shell invocation starts a new
\textit{session} using a UUID as a unique session identifier.
In the current implementation, this UUID is also generated and
handed out by the service registry.

Following this principle, any session starts with a
completely empty \textit{namespace} containing no names. However,
before the actual session starts and the entering of commands is allowed,
the user is presented with a setup phase. In this \textit{import phase}
she can only use the \textit{import} keyword to \textit{upload}
files from the local file system of where the Drift shell is run
into the Drift system.

When the user has finished the import phase, the actual session
begins and normal command input is possible. The \textit{import}
keyword and therefor any further imports are disabled.

\begin{wrapfigure}{l}{0.35\textwidth}
  \begin{lstlisting}
Session: e3d78ad5-898...
.> import data.csv
.> import test.txt
.> q
-------------------
.> ls
  data.csv
  test.txt
.> result = Cat test.txt
.> ls
  data.csv
  result
  test.txt
.> export result as result
.> q

  \end{lstlisting}
  \caption{Example of a short Drift session.}
  \label{drift-import}
\end{wrapfigure}

Fig. \ref{drift-import} shows an example session including the import
phase. Here two local files, namely \texttt{data.csv} and
\texttt{test.txt} are uploaded to the Drift back-end. When the
import phase is finished by pressing $q$, the normal session
begins. This example also introduces one of the few built-in
commands of the Drift shell, namely \texttt{ls}. These built-ins
are again lent from the original UNIX shell and UNIX file system,
so \texttt{ls} is of course used to list all the available names
in the current namespace.

Now with these imported names and associated data, services can
be invoked and their result can be bound to new names. In order
to recognize whether a name resulted from an import or was later
created during the session, only the imported names are allowed
to contain dots and file endings like \texttt{.txt}, \texttt{.csv}
or \texttt{.tar}.

In the same way that the import keyword during the import phase
allows to fill the initial namespace with names, the \textit{export}
keyword allows to \textit{download} the data referenced by a name
to the local file system under a given name. In the current
implementation this can be done at any time during a session
but it could also be a valid alternative to put the export
behavior into a seperate export phase before closing the session.

The local file in which the data is stored is placed inside a
directory with the same name as the session ID, eliminating the
possibility of name clashing between different sessions (of
possibly different users). However, the user of a session is
responsible for preventing name clashes from within a session
when using the \textit{export} keyword.
\newline

So far \textit{names} and \textit{services} and their basic
usage have been introduced. Initial data can be uploaded from
the local file system into the Drift back-end and imported as
names into the initial name space of a session of the Drift shell.
Resulting data from service invocations can be either printed
to the screen or bound to names using the assignment syntax known
from other languages and the namespace can be explored by using
well known file system commands like \texttt{ls}.

However, there are services whose result is not just singular data.
As has already been mentioned, one possible file extension for
imports is \texttt{.tar} and so naturally one service which is
able to deal with such imports is called \texttt{Untar*},
with the \texttt{*} on the right hand side being of significance
because it indicates that the output of \texttt{Untar*} is not
just data (a single file) but rather a bunch of files.
Which is why the concept of \textit{names} in the Drift language
is expanded to also include \textit{namespaces}, which directly
correspond to directories in the original UNIX file system.

Since the result of an invocation of \texttt{Untar*} is a
namespace, it wouldn't really make sense to be able to print
it to the screen. But it would also not make sense to bind
a bunch of names to only a single name, as was shown so far.

Therefor, the result of services returning a namespace must
also always be bind to a namespace.

\begin{wrapfigure}{l}{0.4\textwidth}
  \begin{lstlisting}
Session: e3d78ad5-898...
.> import comments.tar
.> q
-------------------
.> ls
  comments.tar
.> res/ = Untar* comments.tar
.> ls
  comments.tar
  res/
.> cd res/
.> ls
  c1
  c2
  \end{lstlisting}
  \caption{Example of a name space binding.}
  \label{untar}
\end{wrapfigure}

As shown in Fig.\ref{untar} \textit{namespaces} also start with
a lower case letter, just like names but namespaces must always
be trailed by a \texttt{/}. This and the additional \texttt{*}
allow the interpreter to syntactically verify that the issued
command is at least valid in terms of its basic format.

The resulting namespace then of course contains the unpacked
files as new names. This allows the namespace of the whole session
to become a namespace tree in the same way that the UNIX file system
offers a naming tree, using \texttt{/} as a delimiter. Using another
shell built-in, \texttt{cd}, the user can also \textit{walk} the
namespace tree just as with the usual UNIX file system.
